---
title: "Hugo on Azure"
date: 2018-03-19
description: "Easily run Hugo on Azure with deployment triggered by GitHub commits"
image: "media/images/gohugo.png"
categories: ["azure","web"]
tags: ["hugo", "azure", "functions", "serverless"]
draft: true
---

## Overview

Late last year several other Global Black Belts and I decided to create a podcast series and we were looking for a way to host it. We landed on using Hugo since this was mostly going to be static content and and several of us were already familiar with it.

I really wanted to host build this all using serverless products in Azure. So I set out to figure out the best way to accomplish this. I wound up with a CDN sitting in front of blob storage. I then really wanted to get a simple deployment pipeline, so I created an Azure Function that was triggered on GitHub commits of the source content.

We have been using this pattern for a while now and I have deployed several more sites using this same pattern. It has been working pretty well, so I thought I would generalize the project and share this for others to use. In this article I will walk through how I implemented this process.

If you just want to jump to using the template you can get it here:

Now on to how it works. The workflow looks something like this:

## Why not just use Azure Storage like you would on AWS S3?

Azure Storage is perfect for hosting the static content for incredibly cheap if you set the permissing such that the blobs are publicly readable, but there are a few things that keep you from simply using Azure Storage for the whole thing.

1. There is no default document capability. This is the top most requested feature for the storage team and has been for a couple years now, but it still isn't available. Feel free to pile on and vote for it here:

1. Blob Storage requires all blobs to be in a container (basically a directory). This means there is no way to have documents in the root of your site.

1. There is no CI/CD with GitHub directly in Storage (This one applies to AWS S3 too). So you have to use something Like Jenkins, VSTS, Azure Automation, Functions or some other tool to push the file to storage when there is new content to be published.

## What I Implemented

## CDN

CDN can be used to help with the first two points above. It can point to the container as the root for the site and. with Azure Premium CDN, it can even use a rewrite rule to provide basic default document capability. One drawback to Azure CDN though is that you cannot set up the rewrite rules at deployment time nor and changes to the rules can take several hours to take effect.

With this in mind we use Azure Standard CDN. which allows us to push the files as close to the users as possible minimizing the delivery time to the users.

## Function

In comes Azure Functions to save the day, and nicely resolve the remaining items.

* First, Azure Functions Proxies enables me to address the default documents and allows me to do so in a simple programmatic manner as part of the deployment. While Azure Functions Proxies are pretty cool, but they still, unfortunately, lack regex which would be incredibly useful for rewriting. This means our proxies.json file quickly gets ugly, but I've already written this monstrousity for you and it is wicked fast and cheap. I am hoping to implement a dynamic proxies.json generator, that is built based on the files that are generated by Hugo. I hope to have the for eveyone in a future release. In the meantime the proxies.json, looks like this:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "root": {
            "matchCondition": {
                "route": "/"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/index.html"
        },"favicon": {
            "matchCondition": {
                "route": "/favicon.ico"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/favicon.ico"
        },
        "level1": {
            "matchCondition": {
                "route": "/{level1}/"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{level1}/index.html"
        },
        "level2": {
            "matchCondition": {
                "route": "/{level1}/{level2}/"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{level1}/{level2}/index.html"
        },
        "level3": {
            "matchCondition": {
                "route": "/{level1}/{level2}/{level3}/"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{level1}/{level2}/{level3}/index.html"
        },
        "level4": {
            "matchCondition": {
                "route": "/{level1}/{level2}/{level3}/{level4}/"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{level1}/{level2}/{level3}/{level4}/index.html"
        },
        "rootHtml": {
            "matchCondition": {
                "route": "/{name}.html"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{name}.html"
        },
        "rootCss": {
            "matchCondition": {
                "route": "/{name}.css"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{name}.css"
        },
        "rootJs": {
            "matchCondition": {
                "route": "/{name}.js"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{name}.js"
        },
        "rootPng": {
            "matchCondition": {
                "route": "/{name}.png"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{name}.png"
        },

...
        },
        "level4Md": {
            "matchCondition": {
                "route": "/{level1}/{level2}/{level3}/{level4}/{name}.md"
            },
            "backendUri": "https://%storageAccountName%.blob.core.windows.net/public/{level1}/{level2}/{level3}/{level4}/{name}.md"
        }
    }
```

* Second, since Azure Functions is built on top of the App Services platform, it bings many of the same features. Two such features are GitHub CI/CD deployment and kudu deployment scripts. I use the CI/CD functionality to automatically trigger a deployment everytime we receive a commit webhook from GitHub. I then use a custom kudu deployment script to build the static content and push them to the storage account.

* One additional feature is that I am able to host my backend APIs such as search on the same Azure Function using the same domain.

## How to use it


## Wrap Up

This is far from the only way to publish a static Hugo site on Azure, but it has been working extrememly well and all for pennies a month. I hope not only this template is helpful, but also the walk-though of why I selected the components I did. I'd love to hear any recommendations folks have for how this could be optimized.
